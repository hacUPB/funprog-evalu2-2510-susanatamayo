[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/IYE4ssuc)
# Unidad No 2. 
## Informaci√≥n del estudiante  
Nombre del estudiante:  Susana Tamayo

Id.: 567398

### Tabla de contenido üìö
| üß† Actividad | Titulo|üîó link |
|--------------|--------------|---
| Actividad 1  | Actividad 1: El computador digital moderno üñ•Ô∏è|[Actividad 1](funprog-evalu2-2510-susanatamayo/Actividad_1.md) |
| Actividad 2| Actividad 2: Representaci√≥n de datos digitales #Ô∏è‚É£ |[Actividad 2](funprog-evalu2-2510-susanatamayo/Actividad_2.md)|
| Actividad 3|Actividad 3: AlgoritmosüìÑ|[Actividad 3](funprog-evalu2-2510-susanatamayo/Activida_3.md)|
| Actividad 4|Actividad 4: de algoritmo a c√≥digo fuenteüîÑÔ∏è|[Actividad 4](funprog-evalu2-2510-susanatamayo/Activida_4.md)|
| Retos üèÅ|RETOS|[Retos](funprog-evalu2-2510-susanatamayo/Retos.md) |

# Actividad de invetigaci√≥n.üîç (Actividad 1)

### Concepto de computador.üñ•Ô∏è

Un computador es una m√°quina electr√≥nica que est√° dise√±ada para realizar tareas espec√≠ficas. En muchos pa√≠ses se le conoce como computadora u ordenador, pero todas estas palabras se refieren a lo mismo.

Con esta m√°quina se pueden desarrollar tareas que ahora hacen parte de nuestra vida cotidiana, como elaborar cartas o una hoja de vida, hablar con personas de otros pa√≠ses, hacer presupuestos, jugar y hasta navegar en internet.Un computador es una m√°quina electr√≥nica que est√° dise√±ada para realizar tareas espec√≠ficas. En muchos pa√≠ses se le conoce como computadora u ordenador, pero todas estas palabras se refieren a lo mismo.

Con esta m√°quina se pueden desarrollar tareas que ahora hacen parte de nuestra vida cotidiana, como elaborar cartas o una hoja de vida, hablar con personas de otros pa√≠ses, hacer presupuestos, jugar y hasta navegar en internet.

[Concepto de computador üîó](https://edu.gcfglobal.org/es/informatica-basica/que-es-un-computador/1/)

### Arquitectura de un computador.üë©üèª‚Äçüîß
La arquitectura de un computador se refiere al dise√±o y estructura interna de un sistema inform√°tico, incluyendo su organizaci√≥n y la forma en que interact√∫an sus componentes principales (CPU, memoria, buses y perif√©ricos). Define el conjunto de instrucciones que la CPU puede ejecutar y la manera en que los datos fluyen dentro del sistema.

1. #### Arquitectura CISC.

Se caracteriza por contar con un conjunto de instrucciones complejo y variado, donde una sola instrucci√≥n puede realizar m√∫ltiples operaciones en el hardware.
Su dise√±o permite reducir la cantidad de instrucciones en los programas, optimizando el uso de memoria.
Se encuentra en procesadores de escritorio y servidores, como los de la serie Intel x86 y AMD Ryzen.

2. #### Arquitectura RISC.

Utiliza un conjunto de instrucciones m√°s reducido y optimizado, ejecutando operaciones m√°s simples pero en menor tiempo.
Mejora la eficiencia y velocidad del procesamiento, dado que la mayor√≠a de las instrucciones se completan en un solo ciclo de reloj.
Se emplea en dispositivos modernos como procesadores ARM en smartphones, tabletas y servidores de alto rendimiento, adem√°s de la arquitectura Apple M1/M2 y procesadores IBM Power.

### Hardware. üìü
El hardware es el conjunto de partes f√≠sicas que forman un dispositivo electr√≥nico, como una computadora. Se trata de todos los componentes que se pueden ver y tocar, como el teclado, la pantalla, el disco duro, la placa base, entre otros. 

El hardware es fundamental para el funcionamiento de un dispositivo electr√≥nico, ya que permite almacenar datos, procesar informaci√≥n y emitir √≥rdenes a los programas. 

1. #### CPU. (Unidad Central de Procesamiento)

La CPU (Central Processing Unit) es el componente principal de un computador encargado de ejecutar instrucciones y procesar datos. Act√∫a como el "cerebro" del sistema, coordinando las operaciones y asegurando el correcto funcionamiento del software y hardware.

#### Partes relevantes de la CPU.

#### a) ALU (Unidad Aritm√©tico-L√≥gica)

La ALU (Arithmetic Logic Unit) es el componente de la CPU encargado de realizar operaciones matem√°ticas y l√≥gicas.

##### *Funci√≥n:*

Ejecuta operaciones aritm√©ticas (suma, resta, multiplicaci√≥n, divisi√≥n).

Realiza comparaciones l√≥gicas (AND, OR, NOT, XOR).

Manipula datos en funci√≥n de las instrucciones del programa.

#### b) Unidad de Control.

La Unidad de Control es la parte de la CPU que dirige y coordina la ejecuci√≥n de instrucciones dentro del sistema.

##### *Funci√≥n:*

Decodifica las instrucciones del programa.

Controla el flujo de datos entre la memoria, la ALU y los dispositivos de entrada/salida.

Sincroniza la ejecuci√≥n de procesos mediante se√±ales de control.

#### c) Registros. 

Los registros son peque√±as unidades de almacenamiento dentro de la CPU que guardan temporalmente datos e instrucciones en proceso.

##### *Funci√≥n:*

Almacenan valores intermedios durante la ejecuci√≥n de operaciones.

Mantienen direcciones de memoria y estados de control.

Aceleran el procesamiento al evitar el acceso constante a la memoria RAM.

#### d) Buses.

Los buses son canales de comunicaci√≥n que transportan datos, direcciones y se√±ales de control entre los diferentes componentes del computador.

##### *Funci√≥n:*

*Bus de datos:* Transfiere informaci√≥n entre la CPU, la memoria y los dispositivos de entrada/salida.

*Bus de direcciones:* Transporta las direcciones de memoria de los datos que se est√°n procesando.

*Bus de control:* Env√≠a se√±ales que regulan y sincronizan la actividad del sistema.

#### 2. Memoria de la CPU. 

Registros: Almacena datos y resultados temporales.

*Cach√©:* Almacena datos frecuentemente utilizados.

*Memoria principal (RAM):* Almacena datos y programas temporalmente.

 *Memoria secundaria (Disco duro y unidades externas):* Almacena datos y programas permanentemente.

*Registros:* Almacena datos y resultados temporales.

*Cach√©:* Almacena datos frecuentemente utilizados.

*Memoria principal (RAM):* Almacena datos y programas temporalmente.

 *Memoria secundaria (Disco duro y unidades externas):* Almacena datos y programas permanentemente.

 #### 3. Dipositivos de entrada y salida. 

Teclado, mouse, pantalla, impresora, etc.

#### 4. Buses de datos. 
Conecta los componentes y transfiere datos.

### Software. ‚öôÔ∏è

 El software se refiere a los programas y sistemas que ejecuta un computador.

#### 1. Tipos de software.

 *Software de sistema:*
Es el software que gestiona y controla el hardware del ordenador, proporcionando una plataforma para que otros programas funcionen. Ejemplos incluyen:

Sistemas operativos (Windows, Linux, macOS)

Controladores de dispositivos (drivers)

Herramientas de gesti√≥n del sistema (antivirus, utilidades de diagn√≥stico)

*Software de aplicaci√≥n:*
Son programas dise√±ados para realizar tareas espec√≠ficas para el usuario final. Ejemplos incluyen:

Procesadores de texto (Microsoft Word, Google Docs)

Navegadores web (Google Chrome, Mozilla Firefox)

Aplicaciones de mensajer√≠a (WhatsApp, Telegram)

*Software de desarrollo:*
Tambi√©n conocido como herramientas de programaci√≥n, permite a los desarrolladores crear, probar y mantener otros programas. Ejemplos incluyen:

Editores de c√≥digo (Visual Studio Code, Sublime Text)

Compiladores e int√©rpretes (GCC, Python)

Entornos de desarrollo integrados (IDE) (Eclipse, IntelliJ IDEA)

### Funcionamiento del computador üíª

#### 1. Procesos al encender un computador

*Encendido:* Se suministra energ√≠a a los componentes.

*POST:* El sistema realiza un auto-chequeo del hardware.

*BIOS/UEFI:* Se configura el hardware y se busca el sistema operativo.

*MBR/GPT:* Localiza el cargador de arranque en el disco.

*Bootloader:* Carga el n√∫cleo del sistema operativo.

*Kernel:* Inicia la gesti√≥n de los recursos del sistema.

*Servicios del sistema:* Se cargan procesos esenciales del sistema operativo.

*Pantalla de inicio de sesi√≥n:* El usuario se autentica.

*Aplicaciones y entorno:* Se cargan programas y configuraciones del usuario.

#### 2. visualizaci√≥n de resultados

*Tecla presionada:* El teclado genera un c√≥digo.

*C√≥digo enviado al procesador:* El procesador recibe y procesa el dato.

*Aplicaci√≥n lo procesa:* Realiza la acci√≥n (como mostrar un car√°cter o calcular).

*Salida a la tarjeta gr√°fica:* La tarjeta gr√°fica genera la imagen.

*Resultado en la pantalla:* El monitor muestra el resultado.

#### 3. Codificaci√≥n interna. 

*N√∫meros:* Codificados en binario.

*Texto:* Codificado en ASCII o Unicode.

*Im√°genes:* Codificadas como matrices de p√≠xeles con valores de color (RGB).

*Sonido y video:* Codificados como secuencias de muestras o cuadros.

*Instrucciones de programa:* Codificadas en c√≥digo de m√°quina binario.

*Memoria:* Los datos se almacenan como secuencias de bits y bytes.


#### 4. Unidades de medida de datos.

*Bit (b)*

Es la unidad m√°s peque√±a de informaci√≥n. Un bit puede tener solo uno de dos valores: 0 o 1.

1 bit = 0 o 1 (en t√©rminos binarios)

*Byte (B)*

Un byte est√° compuesto por 8 bits. Se usa com√∫nmente para representar un solo car√°cter (como una letra o un n√∫mero en texto) en sistemas de codificaci√≥n como ASCII.

1 byte = 8 bits.

Ejemplo: La letra A en ASCII es 01000001, que es un byte.

*Kilobyte (KB)*

1 KB = 1,024 bytes (en el sistema binario). Aunque en algunos contextos (como marketing), a veces se considera como 1,000 bytes.

Se usa para representar peque√±os archivos, como documentos de texto simples o im√°genes peque√±as.

 *Megabyte (MB)*

1 MB = 1,024 KB = 1,048,576 bytes.

Se usa para medir archivos m√°s grandes como fotos, canciones de alta calidad o programas de software peque√±os.

 *Gigabyte (GB)*

1 GB = 1,024 MB = 1,073,741,824 bytes.

Es una unidad com√∫n para medir la capacidad de almacenamiento de discos duros, SSDs y memoria RAM.

*Terabyte (TB)*
1 TB = 1,024 GB = 1,099,511,627,776 bytes.

Se utiliza para medir el almacenamiento en discos duros grandes, servidores o grandes vol√∫menes de datos.

*Petabyte (PB)*
1 PB = 1,024 TB = 1,125,899,906,842,624 bytes.

Utilizado para medir la capacidad de almacenamiento de grandes centros de datos y sistemas de almacenamiento a nivel empresarial.

*Exabyte (EB)*

1 EB = 1,024 PB = 1,152,921,504,606,846,976 bytes.

Se utiliza para describir grandes cantidades de datos a nivel global (por ejemplo, en las infraestructuras de almacenamiento de compa√±√≠as tecnol√≥gicas de gran escala).

 *Zettabyte (ZB)*
1 ZB = 1,024 EB = 1,180,591,620,717,411,303,424 bytes.

A menudo se utiliza para referirse a la cantidad total de datos almacenados a nivel global.

*Yottabyte (YB)*

1 YB = 1,024 ZB = 1,208,925,819,614,629,174,706,176 bytes.

Es una unidad extremadamente grande, usada para describir cantidades masivas de datos en el futuro a medida que la tecnolog√≠a contin√∫a evolucionando.

# *Representaci√≥n de datos digitales.* üõ¢Ô∏è (Actividad 2)

## Ejercicio 1. 

### 1.  Representaci√≥n de los datos en una computadora. üñ•Ô∏è

En una computadora, ls representaci√≥n de datos se realiza mediante el sistema binarario, constituido por valores 0 y 1, los n√∫meros , las imagenes o cualquier tipo de informaci√≥n en convertida en una secuencia de BIT, los cuales son procesados por la computadora. 

#### - *Representaci√≥n de n√∫meros.* üî¢

Para la representaci√≥n n√∫merica se usan diferentes codificaci√≥nes, como el sistema binario puro para enteros. 

#### - *Representaci√≥n de letras y caracteres.* üî°

Para la representaci√≥n de letras y caracteres, son representados con est√°ndares como ASCII o Unicode, los cuales asignan un valor n√∫merico a cada s√≠mbolo. 

#### - *Representaci√≥n de im√°genes.* üñºÔ∏è

Las imagenes se reprsentan como matrices de p√≠xeles, donde cada p√≠xel posee un valor num√©rico el cual indica su color, usando modelos como RGB.

### 2. ¬øCu√°ntos estados diferentes pueden ser representados por N variables binarias?0Ô∏è‚É£1Ô∏è‚É£

Toda variable binaria puede adquir una de dos valore, 0 o 1. si se tiene N variables binarios, cada una puede estar en dos estados independientes del las dem√°s.

Por lo tanto, el n√∫mero total de estados diferentes que pueden ser representados por 
ùëÅ
 variables binarias es:


$2^{N}$

 
Este resultado proviene de la regla de la multiplicaci√≥n: dado que cada variable tiene 2 opciones y hay 

ùëÅ
 variables, el total de combinaciones posibles es 

2
√ó
2
√ó
.
.
.
√ó
2
2√ó2√ó...√ó2 (
ùëÅ
N veces), lo que da 
2
ùëÅ
2 
N
 .

### 3. Unidades de almacenamiento de datos que se utilizan en computaci√≥n. ‚öôÔ∏è

|Unidad. | Abreviatura. | Equivalencia en Bytes (Base 10) |Equivalencia en Bytes (Base 2)
|--------|--------------|---------------------------------|-----------------------------|
| Byte | B | 1 Byte | 1 Byte 
| KiloByte | KB|$10^{3}$ = 1.000 Bytes|$2^{10}$ = 1.024 Bytes
| MegaByte | MB | $10^{6}$ = 1.000.000 Bytes | $2^{20}$ = 1.048.576 Bytes
| GigaByte | GB|  $10^{9}$ = 1,000,000,000 Bytes | $2^{30}$ = 1,073,741,824 Bytes
| TeraByte | TB | $10^{12}$ = 1,000,000,000,000 Bytes | $2^{40}$ = 1,099,511,627,776 Bytes
| PetaByte | PB | $10^{15}$ = 1,000,000,000,000,000 Bytes | $2^{50}$ = 1,125,899,906,842,624 Bytes
| ExaByte | EB | $10^{18}$ = 1,000,000,000,000,000,000 Bytes | $2^{60}$ =  1,152,921,504,606,846,976 Byte
| ZettaByte | ZB | $10^{21}$ = 1,000,000,000,000,000,000,000 Bytes | $2^{70}$ = 1,180,591,620,717,411,303,424 Bytes
| YottaByte | YB | $10^{24}$ = 1,000,000,000,000,000,000,000,000 Bytes| $2^{80}$ = 1,208,925,819,614,629,174,706,176 Bytes

### 4. George Bool. üí°

El trabajo de George Boole es fundamental en el √°mbito de la computaci√≥n y el almacenamiento de datos ya que estableci√≥ la logica Booleana, lo cual genera la base del funcionamiento de los sistemas digitales y computacionales modernos. 

## Ejercico 2. 

1Ô∏è‚É£ Para convertir estos n√∫meros binarios a decimales (base 10), utilizamos la expansi√≥n de potencias de 2:

1010101010
2
1010101010 
2
‚Äã
 

1
‚ãÖ
2
9
+
0
‚ãÖ
2
8
+
1
‚ãÖ
2
7
+
0
‚ãÖ
2
6
+
1
‚ãÖ
2
5
+
0
‚ãÖ
2
4
+
1
‚ãÖ
2
3
+
0
‚ãÖ
2
2
+
1
‚ãÖ
2
1
+
0
‚ãÖ
2
0
1‚ãÖ2 
9
 +0‚ãÖ2 
8
 +1‚ãÖ2 
7
 +0‚ãÖ2 
6
 +1‚ãÖ2 
5
 +0‚ãÖ2 
4
 +1‚ãÖ2 
3
 +0‚ãÖ2 
2
 +1‚ãÖ2 
1
 +0‚ãÖ2 
0
 
=
512
+
128
+
32
+
8
+
2
=
682
10
512+128+32+8+2=682 
10
‚Äã
 
11111
2
11111 
2
‚Äã
 

1
‚ãÖ
2
4
+
1
‚ãÖ
2
3
+
1
‚ãÖ
2
2
+
1
‚ãÖ
2
1
+
1
‚ãÖ
2
0
1‚ãÖ2 
4
 +1‚ãÖ2 
3
 +1‚ãÖ2 
2
 +1‚ãÖ2 
1
 +1‚ãÖ2 
0
 
=
16
+
8
+
4
+
2
+
1
=
31
10
=16+8+4+2+1=31 
10
‚Äã
 
10000000
2
10000000 
2
‚Äã
 

1
‚ãÖ
2
7
+
0
‚ãÖ
2
6
+
0
‚ãÖ
2
5
+
0
‚ãÖ
2
4
+
0
‚ãÖ
2
3
+
0
‚ãÖ
2
2
+
0
‚ãÖ
2
1
+
0
‚ãÖ
2
0
1‚ãÖ2 
7
 +0‚ãÖ2 
6
 +0‚ãÖ2 
5
 +0‚ãÖ2 
4
 +0‚ãÖ2 
3
 +0‚ãÖ2 
2
 +0‚ãÖ2 
1
 +0‚ãÖ2 
0
 
=
128
10
=128 
10
‚Äã
 
100100100
2
100100100 
2
‚Äã
 

1
‚ãÖ
2
8
+
0
‚ãÖ
2
7
+
0
‚ãÖ
2
6
+
1
‚ãÖ
2
5
+
0
‚ãÖ
2
4
+
0
‚ãÖ
2
3
+
1
‚ãÖ
2
2
+
0
‚ãÖ
2
1
+
0
‚ãÖ
2
0
1‚ãÖ2 
8
 +0‚ãÖ2 
7
 +0‚ãÖ2 
6
 +1‚ãÖ2 
5
 +0‚ãÖ2 
4
 +0‚ãÖ2 
3
 +1‚ãÖ2 
2
 +0‚ãÖ2 
1
 +0‚ãÖ2 
0
 
=
256
+
32
+
4
=
292
10
=256+32+4=292 
10
‚Äã

2Ô∏è‚É£  Vas a convertir los siguientes  n√∫meros decimales a binarios. Recuerda que el sub√≠ndice 10 significa que el n√∫mero es decimal (`base 10`)

- $127_{10}$
- $246_{10}$
- $1025_{10}$
- $354_{10}$

127 
10
‚Äã
 =1111111 
2
‚Äã
 
246
10
=
11110110
2
246 
10
‚Äã
 =11110110 
2
‚Äã
 
1025
10
=
10000000001
2
1025 
10
‚Äã
 =10000000001 
2
‚Äã
 
354
10
=
101100010
2
354 
10
‚Äã
 =101100010 
2
‚Äã
## Ejercicio 3. üîé
üåü Python
- Los tipos de datos integrados son: dict, list, set, frozenset y tuple. 
- La clase str se utiliza para contener cadenas de caracteres Unicode. 
- Las clases bytes y bytearray se utilizan para contener datos binarios. 
- El tipo entero (int) representa n√∫meros enteros sin decimales. 
- El tipo flotante (float) comprende n√∫meros con decimales. 
- El tipo largo (long) se utiliza para enteros de longitud ilimitada. 

üåü C
- Se usa int para representar n√∫meros enteros en 32 bits. Tambi√©n existen short (16 bits), long (64 bits) y unsigned para valores sin signo.
- Se utilizan float (32 bits) y double (64 bits) para manejar n√∫meros con punto decimal.
- Se representa con char, que almacena un solo car√°cter en formato ASCII (8 bits).
- Aunque no exist√≠a en la versi√≥n original de C, se puede usar _Bool o la biblioteca stdbool.h para definir true y false.
- No hay un tipo espec√≠fico para cadenas; se manejan como arrays de caracteres (char[]).

üåü Java 
- Los tipos primitivos son: int, short, long, double, float, boolean, byte, char.
- byte es un entero de 8 bits.
- short es un entero de 16 bits.
- int es un entero de 32 bits.
- long es un entero de 64 bits.
- float es un n√∫mero en coma flotante de precisi√≥n simple de 32 bits.

üåü C++
- Se usa int para n√∫meros enteros de 32 bits. Tambi√©n existen short (16 bits), long (64 bits) y long long (mayor precisi√≥n). Se pueden declarar como unsigned para valores sin signo.
- Se manejan con float (32 bits) y double (64 bits), con double proporcionando mayor precisi√≥n. Tambi√©n existe long double para c√°lculos m√°s precisos.
- Se usa char para almacenar un solo car√°cter ASCII (8 bits) y wchar_t para caracteres anchos (Unicode).
- Se usa bool, que solo puede tomar true o false.
- Se pueden manejar como arrays de caracteres (char[]), pero C++ tambi√©n introduce std::string, que permite manipular texto de forma m√°s sencilla.

## Ejercicio 4. üë©üèª‚Äçüíª

| Datos| Python | C | Java | C ++ |
|--------------|--------------| ---- | ---| -
| Void |  | X|X| X|
| Char| |X |X|X|
| Int | X |X|X|X |
| Float | X| X| X | 
| Str | X|
| Bool | X||X|X|
| Long | | |X|X
| Complex |X|
| Double | | X |X|X|
| Caracteristicas generales|Tipado din√°mico, sin l√≠mites espec√≠ficos, tipos m√°s flexibles.|Tipado est√°tico, eficiente, bajo nivel.|Tipado est√°tico, m√°s seguro, tipos definidos con compatibilidad Unicode| Similar a C, pero con m√°s capacidad orientada a objetos.

## Ejercicio 5. üß†

üü¢ Se alamacena la informaci√≥n cada 10 segundos durante 24 horas. Calcule cu√°nto espacio total se requiere en memoria para almacenar estos datos. Describe el procedimiento y muestra el resultado final. 

1. Si se sabe que cada 10 segundos tendremos almacenada la informaci√≥n, eso quiere decir que cada minuto se tendran 6 datos, si multiplicamos por los minutos que posee una hora eso seria igual a 360 datos en una hora.

     6 x 60 = 360 datos cada hora. 

2. Si esos 360 datos por hora se multiplican entre las 24 horas de un dia. el resultado seria 8,640, si este resultado lo multiplicamos entre los 19 bits del lenguaje de C el resultado seria 164,160 bits.

    360 x 24 = 8,640 x 19 = 164,160 

3. Para transformar bit a KiloByte el resultado anterios se divide entre 1024 que infiere en la cantidad del bit el resultado seria la cantidad de KiloByte generados en 24 horas. 

    $\frac{164,160}{1024}$ = 160.3 KB generados en 24 horas.

 üü† *Resultado final* : En un lapso de 24 horas se generan 160.3 KB

## 6. Conclusi√≥n üìñ

 - En esta actividad tuvimos la oportunidad de aprenden sobre como las computadoras representan distintos caracteres (Letras, N√∫meros e imagenes.) Ademas pudimos identificar el uso de los n√∫meros bianrios para los computadores y como realixzar transformaciones (N√∫meros binarios a n√∫meros decimales y vice versa)

 - Visualizamos los conceptos de Bite, sus unidades, abreaviaturas y su quivalencian en base 2 y 10.

- Pudimos tener las primeras visualizaciones sobre distintos lenguajes de programaci√≥n (Python, C, Java y C++) conocimos que datos contienen y sus caracteristicas generales y principales

- Finalmente hicimos un ejercicio practico sobre el c√°lculo de espacio en la memoria.

# Algoritmos üí≠(Actividad 3)


## Preguntas y repuestas ‚ùì

 ### Parte 1 : Identificar algoritmos. 
 
 #### a) Una p√°gina web. 

 ‚ùå No representa un algoritmo, ya que es una estructura informativa y representativa, pero este no necesariamente sigue un conjunto de pasos secuenciales cuyo objetivo sea especifico.

 #### b) Una receta para hacer un pastel, donde se indican ingredientes y pasos a seguir.

‚úÖ Si representa un algoritmo, la receta genera un secuencia de pasos definidos cuyo objetivo es obtener un resultado final. 


#### c) "Piensa en un n√∫mero y multipl√≠calo por otro".

‚ùå No representa un algoritmo, aunque este sugiere una operaci√≥n matematica este no especifica instrucciones claras de como se llega a un resualtado.

#### d) Un manual de instrucciones para armar un mueble, con pasos detallados y un orden claro.

‚úÖ Si representa un algoritmo, ya que este proporciona un secuencia ordenada de pasos a seguir con el fin de lograr un objetivo. 

#### e) Una lista de compras organizada en orden alfab√©tico

‚ùå No representa un algoritmo, la lista es una variedad de datos organizados, pero este no define un procceso o una guia de pasos para alcanzar el objetivo especifico. 

### Parte 2 : Variables y Constantes

#### a) El valor de la gravedad en la Tierra, 9.8 m/s¬≤.

üîµ Representa una constante, la aceleraci√≥n de la gravedad en la tierra tiene un valor fijo, el cual no cambia en condiciones normales. 

#### b) La edad de una persona calculada en base al a√±o actual y su a√±o de nacimiento.

üü° Representa una variable, La edad de una persona varia con el tiempo, lo cual la hace directamente proporcional al tiempo. 

#### c) La cantidad de dinero en una cuenta bancaria. 

üü£ Representa una variable, El saldo de una √ßuenta bancaria cambia con cada deposito o retiro. 

#### d) La velocidad de la luz en el vac√≠o, 299,792,458 m/s. 

üü† Representa una constante,el valor de la velocidad de la luz en el vacio es una valor no cambiante. 

#### e) El radio de un c√≠rculo. 

üü¢ Representa una variable,el radio de un c√≠rculo puede cambiar dependiendo del c√≠rculo en cuenti√≥n, por lo cual no es un valor fijo. 

### Parte 3 : Caracter√≠sticas de los algoritmos

#### a)  Para elegir la ruta m√°s corta entre varias ciudades, el algoritmo examina rutas candidatas, deteni√©ndose cuando los cambios en la distancia parecen lo suficientemente peque√±os.

‚ùå No cumple con las caracteristicas de un algoritmo, aunque describe el proceo para encontrar la ruta m√°s corta, la condici√≥n es inexacta lo cual no permite cumplir con la caracteristica principal de un algoritmo. 

``` 
Un algoritmo debe ser preciso y tener un criterio de finalizaci√≥n bien definido.

``` 
#### b) Suma los n√∫meros ingresados y muestra el resultado.
‚úÖ S√≠ cumple con las caracter√≠sticas de un algoritmo,define un procedimiento claro (sumar n√∫meros), tiene entrada (los n√∫meros ingresados), salida (la suma) y es finito (termina cuando se obtiene el resultado).

#### c) Un conjunto de pasos para calcular el √°rea de un rect√°ngulo dado su base y altura.

‚úÖ  S√≠ cumple con las caracter√≠sticas de un algoritmo.Tiene entrada (base y altura), un procedimiento definido (multiplicar base por altura), una salida (el √°rea) y es finito.

#### d) El algoritmo cuenta el n√∫mero de votos obtenidos por cada uno de los candidatos de una elecci√≥n para presidente. Empieza solicitando el nombre del candidato y finaliza cuando se ingresa el valor -1.

‚úÖ S√≠ cumple con las caracter√≠sticas de un algoritmo.Tiene entrada (los votos y nombres de los candidatos), un proceso definido (contar votos), salida (cantidad de votos por candidato) y es finito (termina cuando se ingresa -1).

### Parte 4 : Comprensi√≥n de Herramientas

#### a) El pseudoc√≥digo utiliza s√≠mbolos est√°ndar para representar las operaciones l√≥gicas.

‚ùå FALSO, El pseudoc√≥digo es una descripci√≥n textual estructurada de un algoritmo que no sigue un est√°ndar de s√≠mbolos como los diagramas de flujo. Se basa en palabras clave y una sintaxis similar a la de los lenguajes de programaci√≥n, pero no utiliza s√≠mbolos gr√°ficos espec√≠ficos.

#### b) Los diagramas de flujo son una representaci√≥n gr√°fica de un algoritmo.

‚úÖ CIERTO, Los diagramas de flujo utilizan s√≠mbolos gr√°ficos est√°ndar (√≥valos, rect√°ngulos, rombos, etc.) para representar visualmente la secuencia de pasos de un algoritmo.

#### c) El pseudoc√≥digo debe estar escrito en un lenguaje de programaci√≥n espec√≠fico.

‚ùå FALSO, El pseudoc√≥digo no est√° ligado a un lenguaje de programaci√≥n espec√≠fico. Su prop√≥sito es describir algoritmos de manera clara e independiente de cualquier lenguaje, permitiendo su f√°cil traducci√≥n a distintos lenguajes de programaci√≥n.


#### d) Un diagrama de flujo siempre debe tener un inicio y un fin claramente definidos. 

‚úÖ CIERTO, Un diagrama de flujo debe ser finito y representar un proceso con un punto de inicio y un punto de finalizaci√≥n bien definidos. Esto garantiza que el algoritmo sea claro y ejecutable.

### Parte 5 : Estructuras de control.

üìåLas estructuras de control son herramientas fundamentales en la programaci√≥n y en la toma de decisiones en la vida cotidiana. Permiten dirigir el flujo de ejecuci√≥n de un algoritmo o proceso, dependiendo de condiciones o repeticiones. Se dividen en: 

üî¥*Estructuras condicionales (decisi√≥n):* Ejecutan diferentes acciones seg√∫n se cumpla o no una condici√≥n (Ejemplo:  ```if-else ```).

üîµEstructuras de repetici√≥n (bucles): Permiten ejecutar un bloque de c√≥digo varias veces (Ejemplo: ```for, while```).


#### üß†Ejemplos 

1) Decidir si llevar un paraguas antes de salir de casa.
 ```
 Inicio
    Si est√° lloviendo o hay probabilidad de lluvia Entonces
        Tomar paraguas
    Sino
        No tomar paraguas
    Fin Si
Fin
```
2) Decidir si un estudiante aprueba o reprueba un curso con base en su promedio.

 ```
Inicio
    Escribir "Ingrese la calificaci√≥n del examen 1: "
    Leer calificacion1
    Escribir "Ingrese la calificaci√≥n del examen 2: "
    Leer calificacion2
    Escribir "Ingrese la calificaci√≥n del examen 3: "
    Leer calificacion3

    promedio ‚Üê (calificacion1 + calificacion2 + calificacion3) / 3

    Si promedio >= 6 Entonces
        Escribir "Felicidades, aprobaste el curso!"
    Sino
        Escribir "Lo siento, debes repetir el curso."
    Fin Si
Fin
 
 ```
# Algoritmo a c√≥digo fuenteüîÑÔ∏è (Actividad 4)

 1)  ### Introducci√≥n 
 ‚ùì ¬øPor qu√© crees que el pseudoc√≥digo es √∫til antes de escribir un programa en C?

üí≠ El pseudoc√≥digo es √∫til antes de programar en C porque ayuda a estructurar la l√≥gica del algoritmo sin preocuparse por la sintaxis. Facilita la detecci√≥n de errores, optimiza el desarrollo, mejora la comunicaci√≥n en equipos y ahorra tiempo al escribir c√≥digo. Adem√°s, es ideal para el aprendizaje y la depuraci√≥n antes de la implementaci√≥n final

2) ### Estructura b√°sica del paseudoc√≥digo 

üß† Toma un pseudoc√≥digo de un ejercicio anterior o escribe tu propio pseudoc√≥digo, similar al mostrado en el ejemplo de arriba.
```
Inicio
    Escribir "Ingrese las coordenadas del primer punto (x1, y1):"
    Leer x1, y1
    Escribir "Ingrese las coordenadas del segundo punto (x2, y2):"
    Leer x2, y2
    distancia = sqrt((x2 - x1)^2 + (y2 - y1)^2)
    Escribir "La distancia entre los dos puntos es:", distancia
Fin
```

3) ### Traduciendo el pseudoc√≥digo a c 
‚ùì¬øPor qu√© es importante declarar el tipo de variable (int, float, etc.) antes de usarla en C?

üí≠ Declarar el tipo de variable en C es clave para gestionar la memoria, evitar errores, mejorar la precisi√≥n y optimizar el rendimiento. Ayuda al compilador a reservar espacio, detectar problemas y generar c√≥digo eficiente. 

4) ### Ejemplos adicionales de pseudoc√≥digo y su traducci√≥n 

üß† Escribe tu propio pseudoc√≥digo para calcular el promedio de una lista de calificaciones y trad√∫celo a C.

üìå Pseudocodigo
```
Inicio
    Escribir "Ingrese la cantidad de calificaciones:"
    Leer n
    
    suma ‚Üê 0
    
    Para i ‚Üê 1 hasta n Hacer
        Escribir "Ingrese la calificaci√≥n ", i, ":"
        Leer calificacion
        suma ‚Üê suma + calificacion
    FinPara
    
    promedio ‚Üê suma / n
    
    Escribir "El promedio es: ", promedio
Fin
```
üìå Traducci√≥n a C

```
#include <stdio.h>

int main() {
    int n, i;
    float calificacion, suma = 0, promedio;

    printf("Ingrese la cantidad de calificaciones: ");
    scanf("%d", &n);

    for (i = 1; i <= n; i++) {
        printf("Ingrese la calificaci√≥n %d: ", i);
        scanf("%f", &calificacion);
        suma += calificacion;
    }

    promedio = suma / n;
    printf("El promedio es: %.2f\n", promedio);

    return 0;
}
```

5) ### Buenas pr√°cticas 
üß† ¬øPor qu√© es importante comentar el c√≥digo, aunque sea breve y conciso?

üí≠ Comentar el c√≥digo mejora la comprensi√≥n, facilita la depuraci√≥n, optimiza la colaboraci√≥n y ahorra tiempo en mantenimiento. Es clave para un desarrollo claro y eficiente. 

6) ### Reto final

üöÄ  Toma el pseudoc√≥digo de los 5 primeros ejercicios del Reto y realiza la traducci√≥n a C:

### a)
üìåPseudocodigo 
```
Inicio
    Escribir "Ingrese las coordenadas del primer punto (x1, y1):"
    Leer x1, y1
    Escribir "Ingrese las coordenadas del segundo punto (x2, y2):"
    Leer x2, y2
    distancia = sqrt((x2 - x1)^2 + (y2 - y1)^2)
    Escribir "La distancia entre los dos puntos es:", distancia
Fin
```
 üìå Traducci√≥n a C
```
 #include <stdio.h>
#include <math.h>

int main() {
    double x1, y1, x2, y2, distancia;

    // Solicitar las coordenadas del primer punto
    printf("Ingrese las coordenadas del primer punto (x1, y1): ");
    scanf("%lf %lf", &x1, &y1);

    // Solicitar las coordenadas del segundo punto
    printf("Ingrese las coordenadas del segundo punto (x2, y2): ");
    scanf("%lf %lf", &x2, &y2);

    // Calcular la distancia usando la f√≥rmula de la distancia euclidiana
    distancia = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));

    // Mostrar el resultado
    printf("La distancia entre los dos puntos es: %.2f\n", distancia);

    return 0;
}
```
### b)

üìå Pseudocodigo 
```
Inicio
    Escribir "Ingrese la cantidad de tela en metros:"
    Leer metros
    pulgadas = metros / 0.0254
    Escribir "La cantidad de tela en pulgadas es:", pulgadas
Fin
```
üìå Traducci√≥n a C
```
#include <stdio.h>

int main() {
    double metros, pulgadas;

    // Solicitar la cantidad de tela en metros
    printf("Ingrese la cantidad de tela en metros: ");
    scanf("%lf", &metros);

    // Convertir metros a pulgadas (1 pulgada = 0.0254 metros)
    pulgadas = metros / 0.0254;

    // Mostrar el resultado
    printf("La cantidad de tela en pulgadas es: %.2f\n", pulgadas);

    return 0;
}
```
### c)

üìå Psedocodigo
```
INICIO
    Escribir "Ingrese el valor del cateto A:"
    Leer A
    Escribir "Ingrese el valor del cateto B:"
    Leer B
    C = Ra√≠z Cuadrada(A^2 + B^2)
    Escribir "La hipotenusa es:", C
FIN
```
üìå Traducci√≥n a C
```
#include <stdio.h>
#include <math.h>

int main() {
    double A, B, C;

    // Solicitar los valores de los catetos
    printf("Ingrese el valor del cateto A: ");
    scanf("%lf", &A);

    printf("Ingrese el valor del cateto B: ");
    scanf("%lf", &B);

    // Calcular la hipotenusa usando el Teorema de Pit√°goras
    C = sqrt(A * A + B * B);

    // Mostrar el resultado
    printf("La hipotenusa es: %.2f\n", C);

    return 0;
}
```
### d)

üìå Pseudocodigo 
```
INICIO
    // Solicitar la fecha de nacimiento
    ESCRIBIR "Ingrese el d√≠a de nacimiento:"
    LEER dia_nacimiento
    ESCRIBIR "Ingrese el mes de nacimiento:"
    LEER mes_nacimiento
    ESCRIBIR "Ingrese el a√±o de nacimiento:"
    LEER a√±o_nacimiento


    // Obtener la fecha actual
    OBTENER fecha_actual
    dia_actual ‚Üê DIA(fecha_actual)
    mes_actual ‚Üê MES(fecha_actual)
    a√±o_actual ‚Üê A√ëO(fecha_actual)


    // Calcular la edad
    edad ‚Üê a√±o_actual - a√±o_nac


    // Verificar si ya cumpli√≥ a√±os este a√±o
    SI (mes_actual < mes_nac) O (mes_actual = mes_nac Y dia_actual < dia_nac) ENTONCES
        edad = edad - 1  // A√∫n no ha cumplido a√±os
        ESCRIBIR "A√∫n no ha cumplido a√±os este a√±o."
    SINO SI (mes_actual = mes_nac Y dia_actual = dia_nac) ENTONCES
        ESCRIBIR "Feliz Cumplea√±os!"
    SINO
        ESCRIBIR "Ya cumpli√≥ a√±os este a√±o."
    FIN SI


    // Mostrar la edad
    ESCRIBIR "Edad actual: ", edad
FIN
```
üìå Traducci√≥n a C
```
#include <stdio.h>
#include <time.h>

int main() {
    int dia_nac, mes_nac, a√±o_nac;
    int dia_actual, mes_actual, a√±o_actual, edad;

    // Solicitar la fecha de nacimiento
    printf("Ingrese el d√≠a de nacimiento: ");
    scanf("%d", &dia_nac);
    
    printf("Ingrese el mes de nacimiento: ");
    scanf("%d", &mes_nac);
    
    printf("Ingrese el a√±o de nacimiento: ");
    scanf("%d", &a√±o_nac);

    // Obtener la fecha actual
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    
    dia_actual = tm.tm_mday;
    mes_actual = tm.tm_mon + 1;  // tm_mon es base 0, por eso se suma 1
    a√±o_actual = tm.tm_year + 1900;  // tm_year cuenta desde 1900

    // Calcular la edad
    edad = a√±o_actual - a√±o_nac;

    // Verificar si a√∫n no ha cumplido a√±os en el a√±o actual
    if (mes_actual < mes_nac || (mes_actual == mes_nac && dia_actual < dia_nac)) {
        edad--;  // A√∫n no ha cumplido a√±os este a√±o
        printf("A√∫n no ha cumplido a√±os este a√±o.\n");
    } else if (mes_actual == mes_nac && dia_actual == dia_nac) {
        printf("¬°Feliz Cumplea√±os!\n");
    } else {
        printf("Ya cumpli√≥ a√±os este a√±o.\n");
    }

    // Mostrar la edad actual
    printf("Edad actual: %d a√±os\n", edad);

    return 0;
}
```
### e)

üìå Pseudocodigo
```
INICIO
    DEFINIR horas_trabajadas, pago_por_hora, sueldo COMO NUM√âRICO
    ESCRIBIR "Ingrese las horas trabajadas en la semana:"
    LEER horas_trabajadas
    ESCRIBIR "Ingrese el pago por hora:"
    LEER pago_por_hora

    SI horas_trabajadas > 50 ENTONCES
        ESCRIBIR "Error: No se permite trabajar m√°s de 50 horas."
    SINO
        sueldo ‚Üê 0
        SI horas_trabajadas <= 40 ENTONCES
            sueldo ‚Üê horas_trabajadas * pago_por_hora
        SINO SI horas_trabajadas <= 45 ENTONCES
            sueldo ‚Üê (40 * pago_por_hora) + ((horas_trabajadas - 40) * (2 * pago_por_hora))
        SINO SI horas_trabajadas <= 50 ENTONCES
            sueldo ‚Üê (40 * pago_por_hora) + (5 * 2 * pago_por_hora) + ((horas_trabajadas - 45) * (3 * pago_por_hora))
        FIN SI
        ESCRIBIR "El sueldo semanal es: ", sueldo
    FIN SI
FIN
```
üìå Traducci√≥n a C
```
#include <stdio.h>

int main() {
    float horas_trabajadas, pago_por_hora, sueldo = 0;

    // Solicitar las horas trabajadas y el pago por hora
    printf("Ingrese las horas trabajadas en la semana: ");
    scanf("%f", &horas_trabajadas);

    printf("Ingrese el pago por hora: ");
    scanf("%f", &pago_por_hora);

    // Validar que no se trabajen m√°s de 50 horas
    if (horas_trabajadas > 50) {
        printf("Error: No se permite trabajar m√°s de 50 horas.\n");
    } else {
        // Calcular el sueldo seg√∫n las horas trabajadas
        if (horas_trabajadas <= 40) {
            sueldo = horas_trabajadas * pago_por_hora;
        } else if (horas_trabajadas <= 45) {
            sueldo = (40 * pago_por_hora) + ((horas_trabajadas - 40) * (2 * pago_por_hora));
        } else { // 45 < horas_trabajadas <= 50
            sueldo = (40 * pago_por_hora) + (5 * 2 * pago_por_hora) + ((horas_trabajadas - 45) * (3 * pago_por_hora));
        }

        // Mostrar el sueldo calculado
        printf("El sueldo semanal es: %.2f\n", sueldo);
    }

    return 0;
}
```

‚ùìDespu√©s de este tutorial, ¬øqu√© puntos crees que deber√≠as reforzar para sentirte m√°s seguro al traducir pseudoc√≥digo a C?

üí≠ Considero que la forma de senrime mas segura a la hora de realizar traducciones seria mediante la practica constante. 
